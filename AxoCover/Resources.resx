<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbortTests" xml:space="preserve">
    <value>Abort</value>
  </data>
  <data name="About" xml:space="preserve">
    <value>About</value>
  </data>
  <data name="AutoCover" xml:space="preserve">
    <value>Cover after each build</value>
  </data>
  <data name="BuildAndRefresh" xml:space="preserve">
    <value>Build</value>
  </data>
  <data name="Building" xml:space="preserve">
    <value>Building...</value>
  </data>
  <data name="CalculatingOutputSize" xml:space="preserve">
    <value>Calculating...</value>
  </data>
  <data name="CannotOpenFile" xml:space="preserve">
    <value>Could not open file: {0}.</value>
  </data>
  <data name="CannotOpenPath" xml:space="preserve">
    <value>Could not open path: {0}.</value>
  </data>
  <data name="Classes" xml:space="preserve">
    <value>Classes</value>
  </data>
  <data name="Clear" xml:space="preserve">
    <value>Clear</value>
  </data>
  <data name="CollapseAll" xml:space="preserve">
    <value>Collapse</value>
  </data>
  <data name="CoverageHeader" xml:space="preserve">
    <value>Report</value>
  </data>
  <data name="Debug" xml:space="preserve">
    <value>Debug</value>
  </data>
  <data name="Done" xml:space="preserve">
    <value>Done.</value>
  </data>
  <data name="ExecutingTests" xml:space="preserve">
    <value>Executing tests ({0} / {1})...</value>
  </data>
  <data name="Failed" xml:space="preserve">
    <value>Failed</value>
  </data>
  <data name="FinishingOperation" xml:space="preserve">
    <value>Finishing operation...</value>
  </data>
  <data name="VisualizationSettings" xml:space="preserve">
    <value>Visualization</value>
  </data>
  <data name="GeneratingCoverageReport" xml:space="preserve">
    <value>Generating coverage report...</value>
  </data>
  <data name="InitializingTestRunner" xml:space="preserve">
    <value>Initializing test runner...</value>
  </data>
  <data name="Introduction" xml:space="preserve">
    <value>Open and build a solution to start testing.</value>
  </data>
  <data name="License" xml:space="preserve">
    <value>License</value>
  </data>
  <data name="Namespaces" xml:space="preserve">
    <value>Namespaces</value>
  </data>
  <data name="None" xml:space="preserve">
    <value>None</value>
  </data>
  <data name="OutputDirectories" xml:space="preserve">
    <value>Output directories</value>
  </data>
  <data name="Passed" xml:space="preserve">
    <value>Passed</value>
  </data>
  <data name="Ready" xml:space="preserve">
    <value>Ready.</value>
  </data>
  <data name="ReleaseNotes" xml:space="preserve">
    <value>Release notes</value>
  </data>
  <data name="Run" xml:space="preserve">
    <value>Run</value>
  </data>
  <data name="ScanningForTests" xml:space="preserve">
    <value>Scanning solution for tests...</value>
  </data>
  <data name="SettingsHeader" xml:space="preserve">
    <value>Settings</value>
  </data>
  <data name="ShowLineCoverage" xml:space="preserve">
    <value>Line coverage</value>
  </data>
  <data name="Source" xml:space="preserve">
    <value>Source</value>
  </data>
  <data name="StackItemFormat" xml:space="preserve">
    <value>at {0}</value>
  </data>
  <data name="TestRunAborted" xml:space="preserve">
    <value>Test run aborted.</value>
  </data>
  <data name="TestRunFailed" xml:space="preserve">
    <value>Test run failed.</value>
  </data>
  <data name="TestRunners" xml:space="preserve">
    <value>Test runners</value>
  </data>
  <data name="Tests" xml:space="preserve">
    <value>Tests</value>
  </data>
  <data name="TestSearchPlaceholder" xml:space="preserve">
    <value>Search test methods, classes, namespaces and projects</value>
  </data>
  <data name="TestSettings" xml:space="preserve">
    <value>Test settings</value>
  </data>
  <data name="TestsHeader" xml:space="preserve">
    <value>Tests</value>
  </data>
  <data name="Warnings" xml:space="preserve">
    <value>Warnings</value>
  </data>
  <data name="WebSite" xml:space="preserve">
    <value>Web site</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>Error</value>
  </data>
  <data name="Inconclusive" xml:space="preserve">
    <value>Inconclusive</value>
  </data>
  <data name="OutputDirectorySettingsDescription" xml:space="preserve">
    <value>Investigate files used for testing and free up space consumed by leftovers.</value>
  </data>
  <data name="TestRunnerSettingsDescription" xml:space="preserve">
    <value>Test runners affect things such as how files are deployed for tests, the order of execution and performance. If you find tests failing during coverage runs but passing otherwise, try selecting a different test runner here.</value>
  </data>
  <data name="DebugTests" xml:space="preserve">
    <value>Debug tests</value>
  </data>
  <data name="GoToSource" xml:space="preserve">
    <value>Go to source</value>
  </data>
  <data name="RunTests" xml:space="preserve">
    <value>Run tests</value>
  </data>
  <data name="Branches" xml:space="preserve">
    <value>Branches</value>
  </data>
  <data name="Coverage" xml:space="preserve">
    <value>Coverage</value>
  </data>
  <data name="Lines" xml:space="preserve">
    <value>Lines</value>
  </data>
  <data name="Methods" xml:space="preserve">
    <value>Methods</value>
  </data>
  <data name="Total" xml:space="preserve">
    <value>Total</value>
  </data>
  <data name="Uncovered" xml:space="preserve">
    <value>Uncovered</value>
  </data>
  <data name="CoverageExplorerPlaceholder" xml:space="preserve">
    <value>Cover tests to get a coverage report.</value>
  </data>
  <data name="CoverageSearchPlaceholder" xml:space="preserve">
    <value>Search coverage results of methods, classes, namespaces and projects</value>
  </data>
  <data name="ResultsTrimmed" xml:space="preserve">
    <value>Results trimmed for better performance. Please refine query.</value>
  </data>
  <data name="GenerateReport" xml:space="preserve">
    <value>Export</value>
  </data>
  <data name="GeneratingReport" xml:space="preserve">
    <value>Generating report...</value>
  </data>
  <data name="OK" xml:space="preserve">
    <value>OK</value>
  </data>
  <data name="ReportGenerator" xml:space="preserve">
    <value>Report generator</value>
  </data>
  <data name="CoverageSettings" xml:space="preserve">
    <value>Coverage</value>
  </data>
  <data name="ExcludeAttributes" xml:space="preserve">
    <value>Exclude attributes</value>
  </data>
  <data name="ExcludeAttributesDescription" xml:space="preserve">
    <value>Exclude a class or method by filter(s) that match attributes that have been applied. An * can be used as a wildcard. Syntax: &lt;filter&gt;[;filter][;filter].</value>
  </data>
  <data name="ExcludeDirectories" xml:space="preserve">
    <value>Exclude directories</value>
  </data>
  <data name="ExcludeDirectoriesDescription" xml:space="preserve">
    <value>Assemblies being loaded from these locations will be ignored. Syntax: &lt;path to exclude&gt;[;&lt;path to exclude&gt;].</value>
  </data>
  <data name="ExcludeFiles" xml:space="preserve">
    <value>Exclude files</value>
  </data>
  <data name="ExcludeFilesDescription" xml:space="preserve">
    <value>Exclude a class (or methods) by filter(s) that match the filenames. An * can be used as a wildcard. Syntax: &lt;filter&gt;[;&lt;filter&gt;][;&lt;filter&gt;].</value>
  </data>
  <data name="Filters" xml:space="preserve">
    <value>Filters</value>
  </data>
  <data name="FiltersDescription" xml:space="preserve">
    <value>A list of filters to apply to selectively include or exclude assemblies and classes from coverage results. Syntax: (+|-)[Assembly-Filter]Type-Filter.</value>
  </data>
  <data name="ShowBranchCoverage" xml:space="preserve">
    <value>Branch coverage</value>
  </data>
  <data name="ShowExceptions" xml:space="preserve">
    <value>Exceptions</value>
  </data>
  <data name="ShowPartialCoverage" xml:space="preserve">
    <value>Partial coverage</value>
  </data>
  <data name="IsExcludingTestAssemblies" xml:space="preserve">
    <value>Exclude test assemblies</value>
  </data>
  <data name="IsIncludingSolutionAssemblies" xml:space="preserve">
    <value>Include solution output only</value>
  </data>
  <data name="TestExecutionFinished" xml:space="preserve">
    <value>Test execution finished.</value>
  </data>
  <data name="TestExecutionStarted" xml:space="preserve">
    <value>Test execution started.</value>
  </data>
  <data name="TestExplorerPlaceholder" xml:space="preserve">
    <value>Hmm... AxoCover found no unit tests in this solution. Maybe you wanted to add a new unit test project and some tests? Or, open an existing coverage report:</value>
  </data>
  <data name="IsCoveringByTest" xml:space="preserve">
    <value>Calculate coverage of each test separately</value>
  </data>
  <data name="CoverageColors" xml:space="preserve">
    <value>Coverage colors</value>
  </data>
  <data name="Covered" xml:space="preserve">
    <value>Covered</value>
  </data>
  <data name="ExceptionColors" xml:space="preserve">
    <value>Exception colors</value>
  </data>
  <data name="Mixed" xml:space="preserve">
    <value>Mixed</value>
  </data>
  <data name="Origin" xml:space="preserve">
    <value>Origin</value>
  </data>
  <data name="Selected" xml:space="preserve">
    <value>Selected</value>
  </data>
  <data name="Trace" xml:space="preserve">
    <value>Trace</value>
  </data>
  <data name="VisualAids" xml:space="preserve">
    <value>Visual aids</value>
  </data>
  <data name="Assemblies" xml:space="preserve">
    <value>Assemblies</value>
  </data>
  <data name="OpenIssues" xml:space="preserve">
    <value>Issue tracker</value>
  </data>
  <data name="SendFeedback" xml:space="preserve">
    <value>Send feedback</value>
  </data>
  <data name="EnableTelemetry" xml:space="preserve">
    <value>Enable telemetry</value>
  </data>
  <data name="ExceptionEncountered" xml:space="preserve">
    <value>AxoCover encountered an error:</value>
  </data>
  <data name="Feedback" xml:space="preserve">
    <value>Feedback</value>
  </data>
  <data name="FeedbackDescription" xml:space="preserve">
    <value>AxoCover is a small project and lacks the resources to test all possibilities which it might encounter in the wild. Please help us with providing feedback to make AxoCover even better.</value>
  </data>
  <data name="SourceCode" xml:space="preserve">
    <value>Source code</value>
  </data>
  <data name="TelemetryDescription" xml:space="preserve">
    <value>AxoCover can record unhandled exceptions and automatically upload them to our HockeyApp portal for investigation. Telemetry data includes Visual Studio and Windows version and a unique installation ID which helps us determine how many users are affected by a specific problem. We do not collect any of your personal information or source code.</value>
  </data>
  <data name="VisitorCount" xml:space="preserve">
    <value>Visited {0} time(s)</value>
  </data>
  <data name="JumpToTest" xml:space="preserve">
    <value>Jump to test</value>
  </data>
  <data name="SelectTest" xml:space="preserve">
    <value>Select test</value>
  </data>
  <data name="CoverByTestDescription" xml:space="preserve">
    <value>Calculating coverage by test allows you to select tests and see their coverage highlighted. It also allows you to right click the coverage ribbon in the editor and jump to the tests visiting the given line. On the other hand coverage by test has a slight performance hit and it does increase the size of the coverage report.</value>
  </data>
  <data name="CoverByTestExcludeByTestAssemblyWarning" xml:space="preserve">
    <value>To get coverage by test we need to cover test assemblies too. Hence you cannot exclude test assemblies while also enabling coverage by test.</value>
  </data>
  <data name="TestApartmentState" xml:space="preserve">
    <value>Apartment state</value>
  </data>
  <data name="TestPlatform" xml:space="preserve">
    <value>Platform</value>
  </data>
  <data name="RunSettingsDescription" xml:space="preserve">
    <value>Select a .runSettings file from your solution here. Warning: some of your settings might be overridden or unsupported when executing with AxoCover.</value>
  </data>
  <data name="TestExecutionFailed" xml:space="preserve">
    <value>Test execution failed.</value>
  </data>
  <data name="Cover" xml:space="preserve">
    <value>Cover</value>
  </data>
  <data name="CoverTests" xml:space="preserve">
    <value>Cover tests</value>
  </data>
  <data name="TestDiscoveryFailed" xml:space="preserve">
    <value>Test discovery failed.</value>
  </data>
  <data name="TestDiscoveryFinished" xml:space="preserve">
    <value>Test discovery finished.</value>
  </data>
  <data name="TestDiscoveryStarted" xml:space="preserve">
    <value>Test discovery started.</value>
  </data>
  <data name="DebuggerAttached" xml:space="preserve">
    <value>Debugger attached successfully.</value>
  </data>
  <data name="DebuggerAttaching" xml:space="preserve">
    <value>Attaching debugger...</value>
  </data>
  <data name="DebuggerFailedToAttach" xml:space="preserve">
    <value>Debugger failed to attach.</value>
  </data>
  <data name="DebuggingInProgress" xml:space="preserve">
    <value>Debugging in progress...</value>
  </data>
  <data name="ShutdownFailed" xml:space="preserve">
    <value>Shutdown failed.</value>
  </data>
  <data name="ShuttingDown" xml:space="preserve">
    <value>Shutting down...</value>
  </data>
  <data name="AssemblyVersion" xml:space="preserve">
    <value>Build version is {0}, please reference this in your feedback.</value>
  </data>
  <data name="IsMergingByHash" xml:space="preserve">
    <value>Merge by hash</value>
  </data>
  <data name="IsMergingByHashDescription" xml:space="preserve">
    <value>Under some scenarios e.g. using MSTest, an assembly may be loaded many times from different locations. This option is used to merge the coverage results for an assembly regardless of where it was loaded assuming the assembly has the same file-hash in each location.</value>
  </data>
  <data name="IsSkippingAutoProps" xml:space="preserve">
    <value>Skip auto properties</value>
  </data>
  <data name="IsSkippingAutoPropsDescription" xml:space="preserve">
    <value>Neither track nor record auto-implemented properties. That is, skip getters and setters like these: public bool Service { get; set; }</value>
  </data>
  <data name="TelemetryUploadingDisabled" xml:space="preserve">
    <value>Telemetry is disabled, you can make an exception and upload this report, or go to GitHub and raise an issue there.</value>
  </data>
  <data name="TelemetryUploadingFailed" xml:space="preserve">
    <value>Telemetry failed to upload the crash report.</value>
  </data>
  <data name="TelemetryUploadingInProgress" xml:space="preserve">
    <value>Telemetry is uploading the crash report...</value>
  </data>
  <data name="TelemetryUploadingSucceeded" xml:space="preserve">
    <value>Telemetry uploaded the crash report.</value>
  </data>
  <data name="TerminalException" xml:space="preserve">
    <value>Fatal error</value>
  </data>
  <data name="TerminalExceptionDescription" xml:space="preserve">
    <value>AxoCover ran into an exception which it could not handle, to recover from the error Visual Studio needs to be restarted.</value>
  </data>
  <data name="GoToIssues" xml:space="preserve">
    <value>Go to issues...</value>
  </data>
  <data name="PushException" xml:space="preserve">
    <value>Push exception</value>
  </data>
  <data name="Restart" xml:space="preserve">
    <value>Restart</value>
  </data>
  <data name="TerminalExceptionIssues" xml:space="preserve">
    <value>Go to issues on GitHub and post issue manually.</value>
  </data>
  <data name="TerminalExceptionPushDescription" xml:space="preserve">
    <value>Push this exception to telemetry, even if telemetry is otherwise disabled.</value>
  </data>
  <data name="TerminalExceptionRestartVisualStudio" xml:space="preserve">
    <value>Restart Visual Studio.</value>
  </data>
  <data name="TestAdapterMode" xml:space="preserve">
    <value>Adapter mode</value>
  </data>
  <data name="RunSettings" xml:space="preserve">
    <value>Run settings</value>
  </data>
  <data name="TestAdapterModeDescription" xml:space="preserve">
    <value>Use the integrated adapter mode for executing MSTestV1 tests and the standard mode for MSTestV2, NUnit and xUnit tests.</value>
  </data>
  <data name="TestApartmentStateDescription" xml:space="preserve">
    <value>Select the COM threading model for tests here. Most UI applications require using the single-threaded apartment (STA) model, while non-UI applications can use the multi-threaded apartment (MTA) model too.</value>
  </data>
  <data name="TestPlatformDescription" xml:space="preserve">
    <value>While most .Net code can run on a number of platforms (compiled to "Any CPU"). If you use libraries compiled to a specific platform then it is important to specify it here, otherwise your assemblies might fail to load.</value>
  </data>
  <data name="ReleaseManager" xml:space="preserve">
    <value>Releases and updates</value>
  </data>
  <data name="AutoUpdateWarning" xml:space="preserve">
    <value>Make sure to disable automatic updates for AxoCover extension in Visual Studio otherwise it might interfere with the update system in AxoCover.</value>
  </data>
  <data name="BranchesDescription" xml:space="preserve">
    <value>AxoCover is getting more features as time goes, if you want to try them and give feedback, you can select a development branch here:</value>
  </data>
  <data name="DevelopmentBranchDescription" xml:space="preserve">
    <value>The master branch is used to test completed features before they are released. This branch should have most things working, but expect to run into some bugs and regressions occasionally.</value>
  </data>
  <data name="FeatureBranchDescription" xml:space="preserve">
    <value>Feature branches offer access to the latest features during their development. Because of this they are expected to contain various issues until the later stage of their development, so these releases are only recommended for testing.</value>
  </data>
  <data name="InstallingUpdate" xml:space="preserve">
    <value>Installing {0}...</value>
  </data>
  <data name="InstallUpdate" xml:space="preserve">
    <value>Update</value>
  </data>
  <data name="IsUpdatingAutomatically" xml:space="preserve">
    <value>Install updates automatically</value>
  </data>
  <data name="ReleaseBranchDescription" xml:space="preserve">
    <value>The release branch offers the most stable experience and it is recommended for most users.</value>
  </data>
  <data name="Releases" xml:space="preserve">
    <value>Releases &amp; updates</value>
  </data>
  <data name="RestartVisualStudio" xml:space="preserve">
    <value>Restart</value>
  </data>
  <data name="Rollback" xml:space="preserve">
    <value>Roll back</value>
  </data>
  <data name="RollbackDescription" xml:space="preserve">
    <value>If you ran into an issue which interferes with your work, you can roll back to an earlier version here. Don't forget to check the issues board, so we can resolve the issue in the meantime!</value>
  </data>
  <data name="RetryUpdate" xml:space="preserve">
    <value>Retry</value>
  </data>
  <data name="UpdateFailed" xml:space="preserve">
    <value>Update to {0} failed.</value>
  </data>
  <data name="UpdateSucceeded" xml:space="preserve">
    <value>Update to {0} succeeded.</value>
  </data>
  <data name="CheckForUpdates" xml:space="preserve">
    <value>Refresh</value>
  </data>
  <data name="UpdateCheckTime" xml:space="preserve">
    <value>Last checked for updates at {0}.</value>
  </data>
  <data name="DesktopOnlyNote" xml:space="preserve">
    <value>AxoCover supports only the desktop version of .Net Framework. .Net Core / Xamarin projects are NOT supported.</value>
  </data>
  <data name="FrameworkNote" xml:space="preserve">
    <value>These are the currently supported versions, others might or might not work. Please report all issues you encounter on GitHub.</value>
  </data>
  <data name="SupportedTestFrameworks" xml:space="preserve">
    <value>Supported test frameworks:</value>
  </data>
  <data name="ConsoleOutput" xml:space="preserve">
    <value>Console output</value>
  </data>
  <data name="ErrorMessageAndStackTrace" xml:space="preserve">
    <value>Error message &amp; stack-trace</value>
  </data>
  <data name="IsRedirectingFrameworkAssemblies" xml:space="preserve">
    <value>Redirect DLLs of test framework assemblies</value>
  </data>
  <data name="IsRedirectingFrameworkAssembliesDescription" xml:space="preserve">
    <value>When incompatible versions of test framework or adapter DLLs are found inside a solution or AxoCover, it can cause numerous problems, such as failed test discovery or execution. By enabling this feature the runner will redirect I/O operations targerted towards these assemblies to ensure that the correct versions are used everywhere.</value>
  </data>
  <data name="TestProtocol" xml:space="preserve">
    <value>Test protocol</value>
  </data>
  <data name="TestProtocolDescription" xml:space="preserve">
    <value>Some firewalls might interfere with the communication between Visual Studio and the test runner process. Choosing a different option here might resolve the issue.</value>
  </data>
  <data name="DebugTest" xml:space="preserve">
    <value>Debug test</value>
  </data>
  <data name="DebuggerTimeout" xml:space="preserve">
    <value>Debugger timeout</value>
  </data>
  <data name="DebuggerTimeoutDescription" xml:space="preserve">
    <value>This is the amount of time in which the debugger must attach to the test process before the operation is aborted. You can increase this value if the debugger times out.</value>
  </data>
  <data name="IsDebugModeEnabled" xml:space="preserve">
    <value>Debug mode</value>
  </data>
  <data name="IsDebugModeEnabledDescription" xml:space="preserve">
    <value>If enabled all exceptions will be shown in the output window including handled ones which happen normally during test execution. Also in case of fatal exceptions a break point will be triggered in the executor. This is only recommended for debugging advanced issues with the test runner.</value>
  </data>
  <data name="StartupTimeout" xml:space="preserve">
    <value>Startup timeout</value>
  </data>
  <data name="StartupTimeoutDescription" xml:space="preserve">
    <value>This is the amount of time the UI waits for the test runner to start. You may increase this value if you experience timeouts on test runner startup, this can happen if you have slow storage devices or very large test projects.</value>
  </data>
  <data name="IsVisitorCountLimited" xml:space="preserve">
    <value>Limit visitor count</value>
  </data>
  <data name="IsVisitorCountLimitedDescription" xml:space="preserve">
    <value>Limiting the count of recorded visitors can improve coverage profiling performance while the reported coverage remains the same - the visitor counts will be truncated however.</value>
  </data>
  <data name="LoadingSolution" xml:space="preserve">
    <value>Loading solution...</value>
  </data>
  <data name="IsAutoBuildEnabled" xml:space="preserve">
    <value>Build project automatically</value>
  </data>
  <data name="CoverTest" xml:space="preserve">
    <value>Cover test</value>
  </data>
  <data name="RunTest" xml:space="preserve">
    <value>Run test</value>
  </data>
  <data name="ShowAnchors" xml:space="preserve">
    <value>Test anchors</value>
  </data>
  <data name="OpenCoverageReport" xml:space="preserve">
    <value>Open external report</value>
  </data>
  <data name="OpenCoverageReportFilter" xml:space="preserve">
    <value>OpenCover coverage reports (*.xml)|*.xml|All files (*.*)|*.*</value>
  </data>
  <data name="OpenReport" xml:space="preserve">
    <value>Import</value>
  </data>
  <data name="OpenCoverageFailed" xml:space="preserve">
    <value>Cannot import OpenCover coverage file {0}.</value>
  </data>
  <data name="RegisterAs" xml:space="preserve">
    <value>Register coverage profiler as</value>
  </data>
  <data name="RegisterAsDescription" xml:space="preserve">
    <value>User under which OpenCover coverage profiler gets registered. Empty value will setup type of user "administrator" or "user" based on IDE current user.</value>
  </data>
</root>